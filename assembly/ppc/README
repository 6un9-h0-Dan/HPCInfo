= Overview =

See [http://en.wikipedia.org/wiki/PowerPC Wikipedia] for now.

= Documentation =

See [https://www.power.org/ Power.org] for ISA documentation.

= Atomics =

<tt>lwarx</tt> and <tt>stwcx</tt>

== Example Code ==

This code was for Blue Gene/P but the comments in the source make it clear that it is generic to PowerPC.

<pre>
#include <bpcore/bgp_atomic_ops.h>
// This is the relevant excerpt from the header to show that 
// nothing about this code is really BGP-specific:
/**********************************
//@MG: Note alignment need not be this coarse (32B), but must be >= 8B.
typedef struct T_BGP_Atomic
                {
                volatile uint32_t atom;
                }
                ALIGN_L1D_CACHE _BGP_Atomic;
    
// eg: _BGP_Atomic my_atom = _BGP_ATOMIC_INIT( 0 );
//
#define _BGP_ATOMIC_INIT(val) { (val) }
**********************************/

_BGP_Atomic global_atomic = _BGP_ATOMIC_INIT(0);
volatile uint32_t global_lock __attribute__((__aligned__(16)));

static __inline__ uint32_t testandset(volatile uint32_t *global_lock)
{
  uint32_t ret;
  uint32_t val = 1;

  __asm__ volatile(
                   "loop:   lwarx   %0,0,%1   \n"
                   "            stwcx.  %2,0,%1   \n"
                   "            bne-    loop      "
                   : "=r" (ret)
                   : "r" (global_lock)
                   : "r" (val)
                  );
   return ret;
}

static __inline__ void reset(volatile uint32_t *global_lock)
{
  uint32_t val = 0;

  __asm__ volatile(
                   "            mr      %0,%1"
                   : "=r" (global_lock)
                   : "r" (val)
                  );
   return;
}

void global_lock_acquire()
{
   while(testandset(&global_lock));
   return;
}

void global_lock_release()
{
   reset(&global_lock);
   return;
}
</pre>

Here's some more examples:
<pre>
/*
 * Written by Jeff Hammond, July 2012
 * Copyright Argonne National Laboratory
 *
 * This implementation of BGQ atomics is based upon 
 * hwi/include/bqc/A2_inlines.h but uses signed integers
 * instead of unsigned integer and/or long types.
 *
 * In theory, this should work for any PowerPC system.  Need to verify on Blue Gene/P and POWER7. 
 */

#include <stdint.h>

#ifndef __INLINE__
#define __INLINE__ extern inline __attribute__((always_inline))
#endif

/* Not yet verified for use on non-BGQ PPC but not active there anyways */
#if defined(__bgq__) || defined(__bgp__) || defined(__powerpc__)
__INLINE__ int32_t LoadReservedSigned32( volatile int32_t *pVar )
{
   register int32_t Val;
   asm volatile ("lwarx   %[rc],0,%[pVar];"
                 : [rc] "=&b" (Val)
                 : [pVar] "b" (pVar));
   return(Val);
}

__INLINE__ int StoreConditionalSigned32( volatile int32_t *pVar, int32_t Val )
{
   register int rc = 1; // assume success
   asm volatile ("  stwcx.  %2,0,%1;"
                 "  beq     1f;"       // conditional store succeeded
                 "  li      %0,0;"
                 "1:;"
                 : "=b" (rc)
                 : "b"  (pVar),
                   "b"  (Val),
                   "0"  (rc)
                 : "cc", "memory" );
   return(rc);
}

__INLINE__ int32_t CompareAndSwapSigned32( volatile int32_t *var, int32_t  Compare, int32_t  NewValue )
{
    asm volatile ("msync" : : : "memory");

    int32_t OldValue = *var;

    do {
       int32_t TmpValue = LoadReservedSigned32( var );
       if ( Compare != TmpValue  ) return(OldValue);
       }
       while( !StoreConditionalSigned32( var, NewValue ) );

    return(OldValue);
}

__INLINE__ int32_t FetchAndAddSigned32( volatile int32_t *pVar, int32_t value )
{
    asm volatile ("msync" : : : "memory");

    register int32_t old_val, tmp_val;

    do
    {
        old_val = LoadReservedSigned32( pVar );
        tmp_val = old_val + value;
    }
    while ( !StoreConditionalSigned32( pVar, tmp_val ) );

    return( old_val );
}

__INLINE__ void MemoryBarrier(void)
{
    asm volatile ("msync" : : : "memory");

    return;
}

#else
#error You cannot use PowerPC assembly on a non-PowerPC architecture!
#endif
</pre>
